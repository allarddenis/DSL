/*
 * generated by Xtext 2.12.0
 */
package org.xtext.selenium.eliedenis.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.selenium.eliedenis.eDdsl.ActionNoReturn;
import org.xtext.selenium.eliedenis.eDdsl.ActionReturn;
import org.xtext.selenium.eliedenis.eDdsl.All;
import org.xtext.selenium.eliedenis.eDdsl.Attribute;
import org.xtext.selenium.eliedenis.eDdsl.Browse;
import org.xtext.selenium.eliedenis.eDdsl.Check;
import org.xtext.selenium.eliedenis.eDdsl.Click;
import org.xtext.selenium.eliedenis.eDdsl.Comparison;
import org.xtext.selenium.eliedenis.eDdsl.Constraint;
import org.xtext.selenium.eliedenis.eDdsl.Count;
import org.xtext.selenium.eliedenis.eDdsl.EDdslPackage;
import org.xtext.selenium.eliedenis.eDdsl.Model;
import org.xtext.selenium.eliedenis.eDdsl.Parameters;
import org.xtext.selenium.eliedenis.eDdsl.Read;
import org.xtext.selenium.eliedenis.eDdsl.Series;
import org.xtext.selenium.eliedenis.eDdsl.Type;
import org.xtext.selenium.eliedenis.eDdsl.Val;
import org.xtext.selenium.eliedenis.eDdsl.Value;
import org.xtext.selenium.eliedenis.eDdsl.VariableGet;
import org.xtext.selenium.eliedenis.eDdsl.VariableSet;
import org.xtext.selenium.eliedenis.services.EDdslGrammarAccess;

@SuppressWarnings("all")
public class EDdslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private EDdslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == EDdslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case EDdslPackage.ACTION_NO_RETURN:
				sequence_ActionNoReturn(context, (ActionNoReturn) semanticObject); 
				return; 
			case EDdslPackage.ACTION_RETURN:
				sequence_ActionReturn(context, (ActionReturn) semanticObject); 
				return; 
			case EDdslPackage.ALL:
				sequence_All(context, (All) semanticObject); 
				return; 
			case EDdslPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case EDdslPackage.BROWSE:
				sequence_Browse(context, (Browse) semanticObject); 
				return; 
			case EDdslPackage.CHECK:
				sequence_Check(context, (Check) semanticObject); 
				return; 
			case EDdslPackage.CLICK:
				sequence_Click(context, (Click) semanticObject); 
				return; 
			case EDdslPackage.COMPARISON:
				sequence_Comparison(context, (Comparison) semanticObject); 
				return; 
			case EDdslPackage.CONSTRAINT:
				sequence_Constraint(context, (Constraint) semanticObject); 
				return; 
			case EDdslPackage.COUNT:
				sequence_Count(context, (Count) semanticObject); 
				return; 
			case EDdslPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case EDdslPackage.PARAMETER:
				sequence_Parameter(context, (org.xtext.selenium.eliedenis.eDdsl.Parameter) semanticObject); 
				return; 
			case EDdslPackage.PARAMETERS:
				sequence_Parameters(context, (Parameters) semanticObject); 
				return; 
			case EDdslPackage.READ:
				sequence_Read(context, (Read) semanticObject); 
				return; 
			case EDdslPackage.SERIES:
				sequence_Series(context, (Series) semanticObject); 
				return; 
			case EDdslPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case EDdslPackage.VAL:
				sequence_Val(context, (Val) semanticObject); 
				return; 
			case EDdslPackage.VALUE:
				sequence_Value(context, (Value) semanticObject); 
				return; 
			case EDdslPackage.VARIABLE_GET:
				sequence_VariableGet(context, (VariableGet) semanticObject); 
				return; 
			case EDdslPackage.VARIABLE_SET:
				sequence_VariableSet(context, (VariableSet) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ActionNoReturn returns ActionNoReturn
	 *     Operation returns ActionNoReturn
	 *
	 * Constraint:
	 *     (
	 *         action=All | 
	 *         action=Browse | 
	 *         action=Check | 
	 *         action=Click | 
	 *         action=Type | 
	 *         action=VariableSet
	 *     )
	 */
	protected void sequence_ActionNoReturn(ISerializationContext context, ActionNoReturn semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActionReturn returns ActionReturn
	 *
	 * Constraint:
	 *     (action=Count | action=Read)
	 */
	protected void sequence_ActionReturn(ISerializationContext context, ActionReturn semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     All returns All
	 *
	 * Constraint:
	 *     operation=ActionNoReturn
	 */
	protected void sequence_All(ISerializationContext context, All semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EDdslPackage.Literals.ALL__OPERATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EDdslPackage.Literals.ALL__OPERATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAllAccess().getOperationActionNoReturnParserRuleCall_1_0(), semanticObject.getOperation());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (attributeName=STRING attributeValue=STRING)
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EDdslPackage.Literals.ATTRIBUTE__ATTRIBUTE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EDdslPackage.Literals.ATTRIBUTE__ATTRIBUTE_NAME));
			if (transientValues.isValueTransient(semanticObject, EDdslPackage.Literals.ATTRIBUTE__ATTRIBUTE_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EDdslPackage.Literals.ATTRIBUTE__ATTRIBUTE_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeAccess().getAttributeNameSTRINGTerminalRuleCall_1_0(), semanticObject.getAttributeName());
		feeder.accept(grammarAccess.getAttributeAccess().getAttributeValueSTRINGTerminalRuleCall_2_0(), semanticObject.getAttributeValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Browse returns Browse
	 *
	 * Constraint:
	 *     url=STRING
	 */
	protected void sequence_Browse(ISerializationContext context, Browse semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EDdslPackage.Literals.BROWSE__URL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EDdslPackage.Literals.BROWSE__URL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBrowseAccess().getUrlSTRINGTerminalRuleCall_1_0(), semanticObject.getUrl());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Check returns Check
	 *
	 * Constraint:
	 *     action=ActionBoolReturn
	 */
	protected void sequence_Check(ISerializationContext context, Check semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EDdslPackage.Literals.CHECK__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EDdslPackage.Literals.CHECK__ACTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCheckAccess().getActionActionBoolReturnParserRuleCall_1_0(), semanticObject.getAction());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Click returns Click
	 *
	 * Constraint:
	 *     (clickableElement=ClickableEnum parameters=Parameters)
	 */
	protected void sequence_Click(ISerializationContext context, Click semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EDdslPackage.Literals.CLICK__CLICKABLE_ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EDdslPackage.Literals.CLICK__CLICKABLE_ELEMENT));
			if (transientValues.isValueTransient(semanticObject, EDdslPackage.Literals.CLICK__PARAMETERS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EDdslPackage.Literals.CLICK__PARAMETERS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClickAccess().getClickableElementClickableEnumEnumRuleCall_1_0(), semanticObject.getClickableElement());
		feeder.accept(grammarAccess.getClickAccess().getParametersParametersParserRuleCall_2_0(), semanticObject.getParameters());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ActionBoolReturn returns Comparison
	 *     Comparison returns Comparison
	 *
	 * Constraint:
	 *     (firstVal=Val comparatorOperator=ComparisonOperatorEnum secondVal=Val)
	 */
	protected void sequence_Comparison(ISerializationContext context, Comparison semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EDdslPackage.Literals.COMPARISON__FIRST_VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EDdslPackage.Literals.COMPARISON__FIRST_VAL));
			if (transientValues.isValueTransient(semanticObject, EDdslPackage.Literals.COMPARISON__COMPARATOR_OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EDdslPackage.Literals.COMPARISON__COMPARATOR_OPERATOR));
			if (transientValues.isValueTransient(semanticObject, EDdslPackage.Literals.COMPARISON__SECOND_VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EDdslPackage.Literals.COMPARISON__SECOND_VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getFirstValValParserRuleCall_1_0(), semanticObject.getFirstVal());
		feeder.accept(grammarAccess.getComparisonAccess().getComparatorOperatorComparisonOperatorEnumEnumRuleCall_2_0(), semanticObject.getComparatorOperator());
		feeder.accept(grammarAccess.getComparisonAccess().getSecondValValParserRuleCall_3_0(), semanticObject.getSecondVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ActionBoolReturn returns Constraint
	 *     Constraint returns Constraint
	 *
	 * Constraint:
	 *     (readableElement=ReadableEnum constraintType=ConstraintTypeEnum expectedVal=Val parameters=Parameters)
	 */
	protected void sequence_Constraint(ISerializationContext context, Constraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EDdslPackage.Literals.CONSTRAINT__READABLE_ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EDdslPackage.Literals.CONSTRAINT__READABLE_ELEMENT));
			if (transientValues.isValueTransient(semanticObject, EDdslPackage.Literals.CONSTRAINT__CONSTRAINT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EDdslPackage.Literals.CONSTRAINT__CONSTRAINT_TYPE));
			if (transientValues.isValueTransient(semanticObject, EDdslPackage.Literals.CONSTRAINT__EXPECTED_VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EDdslPackage.Literals.CONSTRAINT__EXPECTED_VAL));
			if (transientValues.isValueTransient(semanticObject, EDdslPackage.Literals.CONSTRAINT__PARAMETERS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EDdslPackage.Literals.CONSTRAINT__PARAMETERS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstraintAccess().getReadableElementReadableEnumEnumRuleCall_0_0(), semanticObject.getReadableElement());
		feeder.accept(grammarAccess.getConstraintAccess().getConstraintTypeConstraintTypeEnumEnumRuleCall_1_0(), semanticObject.getConstraintType());
		feeder.accept(grammarAccess.getConstraintAccess().getExpectedValValParserRuleCall_2_0(), semanticObject.getExpectedVal());
		feeder.accept(grammarAccess.getConstraintAccess().getParametersParametersParserRuleCall_3_0(), semanticObject.getParameters());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Count returns Count
	 *
	 * Constraint:
	 *     (parameters=Parameters | parameters=ActionReturn)
	 */
	protected void sequence_Count(ISerializationContext context, Count semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     model=Series
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EDdslPackage.Literals.MODEL__MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EDdslPackage.Literals.MODEL__MODEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModelAccess().getModelSeriesParserRuleCall_0(), semanticObject.getModel());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (parameter=Attribute | parameter=Value)
	 */
	protected void sequence_Parameter(ISerializationContext context, org.xtext.selenium.eliedenis.eDdsl.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameters returns Parameters
	 *
	 * Constraint:
	 *     parameters+=Parameter+
	 */
	protected void sequence_Parameters(ISerializationContext context, Parameters semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Read returns Read
	 *
	 * Constraint:
	 *     (readableElement=ReadableEnum parameters=Parameters)
	 */
	protected void sequence_Read(ISerializationContext context, Read semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EDdslPackage.Literals.READ__READABLE_ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EDdslPackage.Literals.READ__READABLE_ELEMENT));
			if (transientValues.isValueTransient(semanticObject, EDdslPackage.Literals.READ__PARAMETERS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EDdslPackage.Literals.READ__PARAMETERS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReadAccess().getReadableElementReadableEnumEnumRuleCall_1_0(), semanticObject.getReadableElement());
		feeder.accept(grammarAccess.getReadAccess().getParametersParametersParserRuleCall_2_0(), semanticObject.getParameters());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Series returns Series
	 *
	 * Constraint:
	 *     (browser=BrowserEnum expectedReturn=BoolEnum operations+=Operation*)
	 */
	protected void sequence_Series(ISerializationContext context, Series semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *
	 * Constraint:
	 *     (textToType=Val parameters=Parameters)
	 */
	protected void sequence_Type(ISerializationContext context, Type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EDdslPackage.Literals.TYPE__TEXT_TO_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EDdslPackage.Literals.TYPE__TEXT_TO_TYPE));
			if (transientValues.isValueTransient(semanticObject, EDdslPackage.Literals.TYPE__PARAMETERS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EDdslPackage.Literals.TYPE__PARAMETERS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeAccess().getTextToTypeValParserRuleCall_1_0(), semanticObject.getTextToType());
		feeder.accept(grammarAccess.getTypeAccess().getParametersParametersParserRuleCall_2_0(), semanticObject.getParameters());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Val returns Val
	 *
	 * Constraint:
	 *     bool=BoolEnum
	 */
	protected void sequence_Val(ISerializationContext context, Val semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EDdslPackage.Literals.VAL__BOOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EDdslPackage.Literals.VAL__BOOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getValAccess().getBoolBoolEnumEnumRuleCall_2_0(), semanticObject.getBool());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Value returns Value
	 *
	 * Constraint:
	 *     value=Val
	 */
	protected void sequence_Value(ISerializationContext context, Value semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EDdslPackage.Literals.VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EDdslPackage.Literals.VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getValueAccess().getValueValParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Val returns VariableGet
	 *     VariableGet returns VariableGet
	 *
	 * Constraint:
	 *     varName=ID
	 */
	protected void sequence_VariableGet(ISerializationContext context, VariableGet semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EDdslPackage.Literals.VARIABLE_GET__VAR_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EDdslPackage.Literals.VARIABLE_GET__VAR_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableGetAccess().getVarNameIDTerminalRuleCall_0(), semanticObject.getVarName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VariableSet returns VariableSet
	 *
	 * Constraint:
	 *     (varName=ID action=ActionReturn)
	 */
	protected void sequence_VariableSet(ISerializationContext context, VariableSet semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EDdslPackage.Literals.VARIABLE_SET__VAR_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EDdslPackage.Literals.VARIABLE_SET__VAR_NAME));
			if (transientValues.isValueTransient(semanticObject, EDdslPackage.Literals.VARIABLE_SET__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EDdslPackage.Literals.VARIABLE_SET__ACTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableSetAccess().getVarNameIDTerminalRuleCall_0_0(), semanticObject.getVarName());
		feeder.accept(grammarAccess.getVariableSetAccess().getActionActionReturnParserRuleCall_2_0(), semanticObject.getAction());
		feeder.finish();
	}
	
	
}
